const parseJsonResponse = (responseBody) => {
	try {
		return JSON.parse(responseBody);
	} catch {
		throw new Error("Google Books returned invalid JSON");
	}
};

const toTitleCase = (value) => {
	const words = value
		.toLowerCase()
		.split(/\s+/)
		.filter((word) => word.length > 0);

	return words
		.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
		.join(" ");
};

const parsePublishYear = (publishedDate) => {
	if (typeof publishedDate !== "string") return null;

	const trimmedDate = publishedDate.trim();
	if (!/^\d{4}-\d{2}-\d{2}$/.test(trimmedDate)) return null;

	const year = Number(trimmedDate.slice(0, 4));
	if (!Number.isFinite(year)) return null;

	return year;
};

const collectImages = (imageLinks) => {
	if (!imageLinks || typeof imageLinks !== "object") return [];

	const imageSet = new Set();
	const imageCandidates = [
		imageLinks.thumbnail,
		imageLinks.smallThumbnail,
		imageLinks.small,
		imageLinks.medium,
		imageLinks.large,
		imageLinks.extraLarge,
	];

	for (const imageUrl of imageCandidates) {
		if (typeof imageUrl !== "string") continue;
		const trimmedImageUrl = imageUrl.trim();
		if (!trimmedImageUrl) continue;
		imageSet.add(trimmedImageUrl);
	}

	return [...imageSet];
};

const collectPeople = (authors, publisher) => {
	const people = [];
	const seenPeople = new Set();

	if (Array.isArray(authors)) {
		for (const author of authors) {
			if (typeof author !== "string") continue;
			const trimmedAuthor = author.trim();
			if (!trimmedAuthor) continue;

			const key = `Author:${trimmedAuthor}`;
			if (seenPeople.has(key)) continue;
			seenPeople.add(key);

			people.push({
				role: "Author",
				source: "google_books",
				identifier: trimmedAuthor,
			});
		}
	}

	if (typeof publisher === "string") {
		const trimmedPublisher = publisher.trim();
		if (trimmedPublisher) {
			const key = `Publisher:${trimmedPublisher}`;
			if (!seenPeople.has(key)) {
				seenPeople.add(key);
				people.push({
					role: "Publisher",
					source: "google_books",
					identifier: trimmedPublisher,
				});
			}
		}
	}

	return people;
};

const collectGenres = (categories, mainCategory) => {
	const genreSet = new Set();

	if (Array.isArray(categories)) {
		for (const category of categories) {
			if (typeof category !== "string") continue;

			for (const genreToken of category.split(" / ")) {
				const titleToken = toTitleCase(genreToken.trim());
				if (!titleToken) continue;
				genreSet.add(titleToken);
			}
		}
	}

	if (typeof mainCategory === "string") {
		const trimmedMainCategory = mainCategory.trim();
		if (trimmedMainCategory) genreSet.add(trimmedMainCategory);
	}

	return [...genreSet];
};

const configValueResponse = await getAppConfigValue("BOOKS_GOOGLE_BOOKS_API_KEY");
if (!configValueResponse?.success)
	throw new Error(
		configValueResponse?.error ?? "Could not load Google Books API key",
	);

const apiKey =
	typeof configValueResponse.data === "string"
		? configValueResponse.data.trim()
		: "";
if (!apiKey) throw new Error("BOOKS_GOOGLE_BOOKS_API_KEY is not configured");

const contextIdentifier =
	typeof context?.identifier === "string" ? context.identifier.trim() : "";
if (!contextIdentifier) throw new Error("identifier is required");

const response = await httpCall(
	"GET",
	`https://www.googleapis.com/books/v1/volumes/${encodeURIComponent(contextIdentifier)}`,
	{ headers: { "x-goog-api-key": apiKey } },
);

if (!response?.success)
	throw new Error(response?.error ?? "Google Books details request failed");

const payload = parseJsonResponse(response.data.body);

const identifier =
	typeof payload?.id === "string" && payload.id.trim()
		? payload.id
		: contextIdentifier;

const volumeInfo =
	payload?.volumeInfo && typeof payload.volumeInfo === "object"
		? payload.volumeInfo
		: null;
const title = typeof volumeInfo?.title === "string" ? volumeInfo.title : "";
if (!title) throw new Error("Google Books payload is missing title");

const pages =
	typeof volumeInfo?.pageCount === "number" && Number.isFinite(volumeInfo.pageCount)
		? Math.trunc(volumeInfo.pageCount)
		: null;

return {
	name: title,
	external_id: identifier,
	properties: {
		pages,
		people: collectPeople(volumeInfo?.authors, volumeInfo?.publisher),
		genres: collectGenres(volumeInfo?.categories, volumeInfo?.mainCategory),
		publish_year: parsePublishYear(volumeInfo?.publishedDate),
		description:
			typeof volumeInfo?.description === "string"
				? volumeInfo.description
				: null,
		source_url: `https://www.google.co.in/books/edition/${title}/${identifier}`,
		assets: {
			remote_images: collectImages(volumeInfo?.imageLinks),
		},
	},
};
