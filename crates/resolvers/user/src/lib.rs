use std::sync::Arc;

use async_graphql::{Context, Object, Result};
use common_models::StringIdObject;
use database_models::{access_link, integration, notification_platform};
use dependent_models::{
    BasicUserDetails, CachedResponse, UserDetailsResult, UserMetadataRecommendationsResponse,
};
use media_models::{
    AuthUserInput, CreateAccessLinkInput, CreateOrUpdateUserIntegrationInput,
    CreateUserNotificationPlatformInput, GetPasswordChangeSessionInput,
    GetPasswordChangeSessionResponse, LoginResult, OidcTokenOutput, ProcessAccessLinkInput,
    ProcessAccessLinkResult, RegisterResult, RegisterUserInput, SetPasswordViaSessionInput,
    UpdateUserNotificationPlatformInput, UserResetResult, UserTwoFactorBackupCodesResponse,
    UserTwoFactorInitiateResponse, UserTwoFactorSetupInput, UserTwoFactorVerifyInput,
    VerifyTwoFactorResult,
};
use traits::AuthProvider;
use user_models::{UpdateUserInput, UserPreferences};
use user_service::UserService;

#[derive(Default)]
pub struct UserQuery;

impl AuthProvider for UserQuery {}

#[Object]
impl UserQuery {
    /// Get metadata recommendations for the currently logged in user.
    async fn user_metadata_recommendations(
        &self,
        gql_ctx: &Context<'_>,
    ) -> Result<CachedResponse<UserMetadataRecommendationsResponse>> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.user_metadata_recommendations(&user_id).await?;
        Ok(response)
    }

    /// Get all access links generated by the currently logged in user.
    async fn user_access_links(&self, gql_ctx: &Context<'_>) -> Result<Vec<access_link::Model>> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.user_access_links(&user_id).await?;
        Ok(response)
    }

    /// Get details about all the users in the service.
    async fn users_list(
        &self,
        gql_ctx: &Context<'_>,
        query: Option<String>,
    ) -> Result<Vec<BasicUserDetails>> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let response = service.users_list(query).await?;
        Ok(response)
    }

    /// Get details about the currently logged in user.
    async fn user_details(&self, gql_ctx: &Context<'_>) -> Result<UserDetailsResult> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let session_id = self.user_session_id_from_ctx(gql_ctx)?;
        let response = service.user_details(&session_id).await?;
        Ok(response)
    }

    /// Get all the integrations for the currently logged in user.
    async fn user_integrations(&self, gql_ctx: &Context<'_>) -> Result<Vec<integration::Model>> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.user_integrations(&user_id).await?;
        Ok(response)
    }

    /// Get all the notification platforms for the currently logged in user.
    async fn user_notification_platforms(
        &self,
        gql_ctx: &Context<'_>,
    ) -> Result<Vec<notification_platform::Model>> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.user_notification_platforms(&user_id).await?;
        Ok(response)
    }

    /// Get an authorization URL using the configured OIDC client.
    async fn get_oidc_redirect_url(&self, gql_ctx: &Context<'_>) -> Result<String> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let response = service.get_oidc_redirect_url().await?;
        Ok(response)
    }

    /// Get an access token using the configured OIDC client.
    async fn get_oidc_token(&self, gql_ctx: &Context<'_>, code: String) -> Result<OidcTokenOutput> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let response = service.get_oidc_token(code).await?;
        Ok(response)
    }

    /// Get user by OIDC issuer ID.
    async fn user_by_oidc_issuer_id(
        &self,
        gql_ctx: &Context<'_>,
        oidc_issuer_id: String,
    ) -> Result<Option<String>> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let response = service.user_by_oidc_issuer_id(oidc_issuer_id).await?;
        Ok(response)
    }
}

#[derive(Default)]
pub struct UserMutation;

impl AuthProvider for UserMutation {
    fn is_mutation(&self) -> bool {
        true
    }
}

#[Object]
impl UserMutation {
    /// Create or edit an access link.
    async fn create_access_link(
        &self,
        gql_ctx: &Context<'_>,
        input: CreateAccessLinkInput,
    ) -> Result<StringIdObject> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.create_access_link(input, user_id).await?;
        Ok(response)
    }

    /// Get an access token using an access link.
    async fn process_access_link(
        &self,
        gql_ctx: &Context<'_>,
        input: ProcessAccessLinkInput,
    ) -> Result<ProcessAccessLinkResult> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let response = service.process_access_link(input).await?;
        Ok(response)
    }

    /// Revoke an access link.
    async fn revoke_access_link(
        &self,
        gql_ctx: &Context<'_>,
        access_link_id: String,
    ) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        self.user_id_from_ctx(gql_ctx).await?;
        let response = service.revoke_access_link(access_link_id).await?;
        Ok(response)
    }

    /// Delete a user. The account deleting the user must be an `Admin`.
    async fn delete_user(&self, gql_ctx: &Context<'_>, to_delete_user_id: String) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.delete_user(user_id, to_delete_user_id).await?;
        Ok(response)
    }

    /// Reset a user by deleting and recreating them with the same ID. The account
    /// resetting the user must be an `Admin`.
    async fn reset_user(
        &self,
        gql_ctx: &Context<'_>,
        to_reset_user_id: String,
    ) -> Result<UserResetResult> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.reset_user(user_id, to_reset_user_id).await?;
        Ok(response)
    }

    /// Create a new user for the service. Also set their `lot` as admin if
    /// they are the first user.
    async fn register_user(
        &self,
        gql_ctx: &Context<'_>,
        input: RegisterUserInput,
    ) -> Result<RegisterResult> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let requester_user_id = self.user_id_from_ctx(gql_ctx).await.ok();
        let response = service.register_user(requester_user_id, input).await?;
        Ok(response)
    }

    /// Login a user using their username and password and return an auth token.
    async fn login_user(&self, gql_ctx: &Context<'_>, input: AuthUserInput) -> Result<LoginResult> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let response = service.login_user(input).await?;
        Ok(response)
    }

    /// Update a user's profile details.
    async fn update_user(
        &self,
        gql_ctx: &Context<'_>,
        input: UpdateUserInput,
    ) -> Result<StringIdObject> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let requester_user_id = self.user_id_from_ctx(gql_ctx).await.ok();
        let response = service.update_user(requester_user_id, input).await?;
        Ok(response)
    }

    /// Change a user's preferences.
    async fn update_user_preference(
        &self,
        gql_ctx: &Context<'_>,
        input: UserPreferences,
    ) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.update_user_preference(user_id, input).await?;
        Ok(response)
    }

    /// Create or update an integration for the currently logged in user.
    async fn create_or_update_user_integration(
        &self,
        gql_ctx: &Context<'_>,
        input: CreateOrUpdateUserIntegrationInput,
    ) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service
            .create_or_update_user_integration(user_id, input)
            .await?;
        Ok(response)
    }

    /// Delete an integration for the currently logged in user.
    async fn delete_user_integration(
        &self,
        gql_ctx: &Context<'_>,
        integration_id: String,
    ) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service
            .delete_user_integration(user_id, integration_id)
            .await?;
        Ok(response)
    }

    /// Add a notification platform for the currently logged in user.
    async fn create_user_notification_platform(
        &self,
        gql_ctx: &Context<'_>,
        input: CreateUserNotificationPlatformInput,
    ) -> Result<String> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service
            .create_user_notification_platform(user_id, input)
            .await?;
        Ok(response)
    }

    /// Edit a notification platform for the currently logged in user.
    async fn update_user_notification_platform(
        &self,
        gql_ctx: &Context<'_>,
        input: UpdateUserNotificationPlatformInput,
    ) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service
            .update_user_notification_platform(user_id, input)
            .await?;
        Ok(response)
    }

    /// Delete a notification platform for the currently logged in user.
    async fn delete_user_notification_platform(
        &self,
        gql_ctx: &Context<'_>,
        notification_id: String,
    ) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service
            .delete_user_notification_platform(user_id, notification_id)
            .await?;
        Ok(response)
    }

    /// Test all notification platforms for the currently logged in user.
    async fn test_user_notification_platforms(&self, gql_ctx: &Context<'_>) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.test_user_notification_platforms(&user_id).await?;
        Ok(response)
    }

    /// Generate an auth token without any expiry.
    async fn generate_auth_token(&self, gql_ctx: &Context<'_>) -> Result<String> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.generate_auth_token(user_id).await?;
        Ok(response)
    }

    /// Verify a two-factor authentication code (TOTP or backup code).
    async fn verify_two_factor(
        &self,
        gql_ctx: &Context<'_>,
        input: UserTwoFactorVerifyInput,
    ) -> Result<VerifyTwoFactorResult> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let response = service.verify_two_factor(input).await?;
        Ok(response)
    }

    /// Initiate two-factor authentication setup by generating a TOTP secret.
    async fn initiate_two_factor_setup(
        &self,
        gql_ctx: &Context<'_>,
    ) -> Result<UserTwoFactorInitiateResponse> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.initiate_two_factor_setup(user_id).await?;
        Ok(response)
    }

    /// Complete two-factor authentication setup by verifying the TOTP code.
    async fn complete_two_factor_setup(
        &self,
        gql_ctx: &Context<'_>,
        input: UserTwoFactorSetupInput,
    ) -> Result<UserTwoFactorBackupCodesResponse> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.complete_two_factor_setup(user_id, input).await?;
        Ok(response)
    }

    /// Disable two-factor authentication for the currently logged in user.
    async fn disable_two_factor(&self, gql_ctx: &Context<'_>) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.disable_two_factor(user_id).await?;
        Ok(response)
    }

    /// Regenerate backup codes for the currently logged in user.
    async fn regenerate_two_factor_backup_codes(
        &self,
        gql_ctx: &Context<'_>,
    ) -> Result<UserTwoFactorBackupCodesResponse> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let user_id = self.user_id_from_ctx(gql_ctx).await?;
        let response = service.regenerate_two_factor_backup_codes(user_id).await?;
        Ok(response)
    }

    /// Logout the current user by invalidating their session.
    async fn logout_user(&self, gql_ctx: &Context<'_>) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let session_id = self.user_session_id_from_ctx(gql_ctx)?;
        let response = service.logout_user(session_id).await?;
        Ok(response)
    }

    /// Get a URL which can be used to set a new password for the user.
    async fn get_password_change_session(
        &self,
        gql_ctx: &Context<'_>,
        input: GetPasswordChangeSessionInput,
    ) -> Result<GetPasswordChangeSessionResponse> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let requester_user_id = self.user_id_from_ctx(gql_ctx).await.ok();
        let response = service
            .get_password_change_session(requester_user_id, input)
            .await?;
        Ok(response)
    }

    /// Set password using a valid session ID (non-authenticated route).
    async fn set_password_via_session(
        &self,
        gql_ctx: &Context<'_>,
        input: SetPasswordViaSessionInput,
    ) -> Result<bool> {
        let service = gql_ctx.data_unchecked::<Arc<UserService>>();
        let response = service.set_password_via_session(input).await?;
        Ok(response)
    }
}
