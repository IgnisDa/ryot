use async_graphql::{Context, Object, Result};
use common_models::StringIdObject;
use database_models::access_link;
use dependent_models::{BasicUserDetails, UserDetailsResult};
use media_models::{
    CreateAccessLinkInput, GetPasswordChangeSessionInput, GetPasswordChangeSessionResponse,
    ProcessAccessLinkInput, ProcessAccessLinkResult, SetPasswordViaSessionInput, UserResetResult,
};
use traits::GraphqlDependencyInjector;
use user_models::{UpdateUserInput, UserPreferences};
use user_service::{
    access_link_operations, authentication_operations, password_change_operations,
    user_data_operations, user_management_operations, user_preferences_operations,
};

#[derive(Default)]
pub struct UserManagementQueryResolver;

impl GraphqlDependencyInjector for UserManagementQueryResolver {}

#[Object]
impl UserManagementQueryResolver {
    /// Get details about all the users in the service.
    async fn users_list(
        &self,
        gql_ctx: &Context<'_>,
        query: Option<String>,
    ) -> Result<Vec<BasicUserDetails>> {
        let service = self.dependency(gql_ctx);
        Ok(user_data_operations::users_list(service, query).await?)
    }

    /// Get details about the currently logged in user.
    async fn user_details(&self, gql_ctx: &Context<'_>) -> Result<UserDetailsResult> {
        let service = self.dependency(gql_ctx);
        let session_id = self.user_session_id_from_ctx(gql_ctx)?;
        Ok(authentication_operations::user_details(service, &session_id).await?)
    }

    /// Get all access links generated by the currently logged in user.
    async fn user_access_links(&self, gql_ctx: &Context<'_>) -> Result<Vec<access_link::Model>> {
        let (service, user_id) = self.dependency_and_user(gql_ctx).await?;
        Ok(user_data_operations::user_access_links(service, &user_id).await?)
    }
}

#[derive(Default)]
pub struct UserManagementMutationResolver;

impl GraphqlDependencyInjector for UserManagementMutationResolver {
    fn is_mutation(&self) -> bool {
        true
    }
}

#[Object]
impl UserManagementMutationResolver {
    /// Delete a user. The account deleting the user must be an `Admin`.
    async fn delete_user(&self, gql_ctx: &Context<'_>, to_delete_user_id: String) -> Result<bool> {
        let (service, user_id) = self.dependency_and_user(gql_ctx).await?;
        Ok(user_management_operations::delete_user(service, user_id, to_delete_user_id).await?)
    }

    /// Reset a user by deleting and recreating them with the same ID. The account
    /// resetting the user must be an `Admin`.
    async fn reset_user(
        &self,
        gql_ctx: &Context<'_>,
        to_reset_user_id: String,
    ) -> Result<UserResetResult> {
        let (service, user_id) = self.dependency_and_user(gql_ctx).await?;
        Ok(user_management_operations::reset_user(service, user_id, to_reset_user_id).await?)
    }

    /// Update a user's profile details.
    async fn update_user(
        &self,
        gql_ctx: &Context<'_>,
        input: UpdateUserInput,
    ) -> Result<StringIdObject> {
        let (service, requester_user_id) = self.dependency_and_maybe_user(gql_ctx).await?;
        Ok(user_management_operations::update_user(input, service, requester_user_id).await?)
    }

    /// Change a user's preferences.
    async fn update_user_preference(
        &self,
        gql_ctx: &Context<'_>,
        input: UserPreferences,
    ) -> Result<bool> {
        let (service, user_id) = self.dependency_and_user(gql_ctx).await?;
        Ok(user_preferences_operations::update_user_preference(service, &user_id, input).await?)
    }

    /// Get a URL which can be used to set a new password for the user.
    async fn get_password_change_session(
        &self,
        gql_ctx: &Context<'_>,
        input: GetPasswordChangeSessionInput,
    ) -> Result<GetPasswordChangeSessionResponse> {
        let (service, requester_user_id) = self.dependency_and_maybe_user(gql_ctx).await?;
        Ok(password_change_operations::get_password_change_session(
            service,
            requester_user_id,
            input,
        )
        .await?)
    }

    /// Set password using a valid session ID (non-authenticated route).
    async fn set_password_via_session(
        &self,
        gql_ctx: &Context<'_>,
        input: SetPasswordViaSessionInput,
    ) -> Result<bool> {
        let service = self.dependency(gql_ctx);
        Ok(password_change_operations::set_password_via_session(
            service,
            input.session_id,
            input.password,
        )
        .await?)
    }

    /// Create or edit an access link.
    async fn create_access_link(
        &self,
        gql_ctx: &Context<'_>,
        input: CreateAccessLinkInput,
    ) -> Result<StringIdObject> {
        let (service, user_id) = self.dependency_and_user(gql_ctx).await?;
        Ok(access_link_operations::create_access_link(service, input, user_id).await?)
    }

    /// Get an access token using an access link.
    async fn process_access_link(
        &self,
        gql_ctx: &Context<'_>,
        input: ProcessAccessLinkInput,
    ) -> Result<ProcessAccessLinkResult> {
        let service = self.dependency(gql_ctx);
        Ok(access_link_operations::process_access_link(service, input).await?)
    }

    /// Revoke an access link.
    async fn revoke_access_link(
        &self,
        gql_ctx: &Context<'_>,
        access_link_id: String,
    ) -> Result<bool> {
        let (service, _) = self.dependency_and_user(gql_ctx).await?;
        Ok(authentication_operations::revoke_access_link(service, access_link_id).await?)
    }
}
